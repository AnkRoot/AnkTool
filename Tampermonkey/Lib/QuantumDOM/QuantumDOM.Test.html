<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>QuantumDOM v2.1.1 Comprehensive Test Suite</title>
    <style>
        :root { --bg: #1e1e2e; --text: #cdd6f4; --panel: #313244; --green: #a6e3a1; --red: #f38ba8; }
        body { font-family: 'Segoe UI', monospace; background: var(--bg); color: var(--text); display: grid; grid-template-columns: 400px 1fr; gap: 20px; padding: 20px; height: 100vh; box-sizing: border-box; margin: 0; }
        .panel { background: var(--panel); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        h3 { margin: 0 0 10px 0; border-bottom: 2px solid #45475a; padding-bottom: 5px; color: #89b4fa; font-size: 16px; }
        
        /* Logs */
        #log { flex: 1; overflow-y: auto; font-size: 13px; font-family: Consolas; }
        .log-item { display: flex; padding: 4px 0; border-bottom: 1px solid #45475a; align-items: center; }
        .badge { padding: 2px 6px; border-radius: 4px; font-weight: bold; font-size: 11px; margin-right: 10px; min-width: 40px; text-align: center; color: #111; }
        .pass { background: var(--green); }
        .fail { background: var(--red); }
        .wait { background: #f9e2af; }
        .info { background: #89b4fa; color: #111; }
        
        /* Playground */
        .zone { border: 1px dashed #6c7086; padding: 10px; margin-bottom: 15px; position: relative; }
        .zone::after { content: attr(data-name); position: absolute; top: 0; right: 0; background: #6c7086; color: white; font-size: 10px; padding: 2px 6px; }
        iframe { border: none; background: white; width: 100%; height: 80px; display: block; }
    </style>
</head>
<body>
    <div class="panel">
        <h3>TEST RUNNER</h3>
        <div style="margin-bottom:10px;">
            <button id="btn-run" style="width:100%; padding:8px; background:#89b4fa; border:none; border-radius:4px; font-weight:bold; cursor:pointer;">RUN DIAGNOSTICS</button>
        </div>
        <div id="log">Ready.</div>
    </div>

    <div class="panel" style="overflow-y:auto;">
        <h3>DOM PLAYGROUND</h3>

        <div class="zone" data-name="Main Context">
            <div id="static-target">Target 1</div>
            <div id="target-2" class="test-class">Target 2</div>
            <div id="dynamic-container"></div>
            <div id="nested-container">
                <div class="deep-nested">
                    <span id="deep-target">Deep Target</span>
                </div>
            </div>
        </div>

        <div class="zone" data-name="Shadow Host">
            <div id="host-1"></div>
            <div id="host-2"></div>
        </div>

        <div class="zone" data-name="Iframe Host">
            <iframe id="frm-1"></iframe>
            <iframe id="frm-2"></iframe>
        </div>

        <div class="zone" data-name="Event Test Zone">
            <button id="btn-test" class="test-btn">Test Button</button>
            <div id="event-container"></div>
        </div>

        <div class="zone" data-name="Error Test Zone">
            <div id="error-container"></div>
        </div>
    </div>

    <!-- Iframe Template -->
    <template id="tpl-frm">
        <style>body{margin:0;padding:10px;background:#fff;}</style>
        <button id="inner-btn">Iframe Button</button>
        <div id="inner-dyn"></div>
    </template>

    <script src="QuantumDOM.user.js"></script>

    <script>
        // --- Global Helper ---
        const $ = s => document.querySelector(s);

        // Setup Shadow DOM hosts
        const host1 = $('#host-1').attachShadow({mode:'open'});
        host1.innerHTML = `<div id="s-content"><span class="s-item">Shadow Item</span><button id="shadow-btn">Shadow Button</button></div>`;

        const host2 = $('#host-2').attachShadow({mode:'open'});
        host2.innerHTML = `
            <style>
                .nested-shadow { border: 1px solid #ccc; padding: 5px; }
                .deep-item { color: blue; }
            </style>
            <div class="nested-shadow">
                <div id="nested-shadow">
                    <span class="deep-item">Deep Shadow Item</span>
                </div>
            </div>
        `;

        // Setup Iframes
        const frm1 = $('#frm-1');
        frm1.srcdoc = $('#tpl-frm').innerHTML;

        const frm2 = $('#frm-2');
        frm2.srcdoc = `
            <style>body{margin:0;padding:10px;background:#f0f0f0;}</style>
            <div id="iframe-2-content">
                <button id="iframe-btn-2">Iframe 2 Button</button>
                <div class="iframe-class">Iframe Content</div>
            </div>
        `;

        // --- Test Engine ---
        const TestUtils = {
            log(status, msg) {
                const el = document.getElementById('log');
                const row = document.createElement('div');
                row.className = 'log-item';
                row.innerHTML = `<span class="badge ${status}">${status.toUpperCase()}</span><span>${msg}</span>`;
                el.appendChild(row);
                el.scrollTop = el.scrollHeight;
            },

            assert(cond, msg) {
                if (!cond) throw new Error(msg);
            },

            wait(ms) {
                return new Promise(r => setTimeout(r, ms));
            },

            async test(name, testFn) {
                this.log('wait', `Running: ${name}`);
                try {
                    await testFn();
                    this.log('pass', name);
                    return true;
                } catch (e) {
                    console.error(e);
                    this.log('fail', `${name}: ${e.message}`);
                    return false;
                }
            },

            async runTests(tests) {
                let passed = 0;
                const total = Object.keys(tests).length;

                for (const [name, fn] of Object.entries(tests)) {
                    if (await this.test(name, fn)) passed++;
                    await this.wait(50);
                }

                this.log('info', `Complete: ${passed}/${total} Passed.`);
                return { passed, total };
            }
        };

        const tests = {
            // === Ê†∏ÂøÉÈÖçÁΩÆÂíåÂàùÂßãÂåñÊµãËØï ===
            async 'Core: Library Loading'() {
                TestUtils.assert(window.QuantumDOM, 'Library not loaded');
                TestUtils.assert(typeof QuantumDOM.get === 'function', 'get method missing');
                TestUtils.assert(typeof QuantumDOM.each === 'function', 'each method missing');
                TestUtils.assert(typeof QuantumDOM.on === 'function', 'on method missing');
                TestUtils.assert(typeof QuantumDOM.create === 'function', 'create method missing');
                TestUtils.assert(typeof QuantumDOM.css === 'function', 'css method missing');
            },

            async 'Core: Configuration Management'() {
                const defaultConfig = QuantumDOM.config;
                TestUtils.assert(defaultConfig.timeout === 10000, 'Default timeout mismatch');
                TestUtils.assert(defaultConfig.cache === true, 'Default cache should be enabled');
                TestUtils.assert(defaultConfig.debug === false, 'Default debug should be disabled');

                QuantumDOM.configure({ timeout: 500, debug: true });
                TestUtils.assert(QuantumDOM.config.timeout === 500, 'Config update failed for timeout');
                TestUtils.assert(QuantumDOM.config.debug === true, 'Config update failed for debug');

                // Reset to defaults
                QuantumDOM.configure({ timeout: 10000, debug: false });
            },

            // === Âü∫Á°ÄËé∑ÂèñÂäüËÉΩÊµãËØï ===
            async 'Get: Element by ID'() {
                const el = await QuantumDOM.get('#static-target');
                TestUtils.assert(el && el.id === 'static-target', 'Failed to get element by ID');
            },

            async 'Get: Element by Class'() {
                const el = await QuantumDOM.get('.test-class');
                TestUtils.assert(el && el.id === 'target-2', 'Failed to get element by class');
            },

            async 'Get: Nested Element'() {
                const el = await QuantumDOM.get('#nested-container .deep-nested #deep-target');
                TestUtils.assert(el && el.id === 'deep-target', 'Failed to get nested element');
            },

            async 'Get: Array of Selectors'() {
                const results = await QuantumDOM.get(['#static-target', '#target-2', '#deep-target']);
                TestUtils.assert(Array.isArray(results), 'Should return array');
                TestUtils.assert(results.length === 3, 'Should return 3 elements');
                TestUtils.assert(results[0].id === 'static-target', 'First element mismatch');
                TestUtils.assert(results[1].id === 'target-2', 'Second element mismatch');
                TestUtils.assert(results[2].id === 'deep-target', 'Third element mismatch');
            },

            // === Shadow DOM Á©øÈÄèÊµãËØï ===
            async 'Shadow: Basic Penetration'() {
                const el = await QuantumDOM.get('#host-1 >>> shadow-root >>> .s-item');
                TestUtils.assert(el && el.textContent === 'Shadow Item', 'Basic shadow penetration failed');
            },

            async 'Shadow: Button in Shadow'() {
                const el = await QuantumDOM.get('#host-1 >>> shadow-root >>> #shadow-btn');
                TestUtils.assert(el && el.tagName === 'BUTTON', 'Failed to get button in shadow');
            },

            async 'Shadow: Nested Structure'() {
                const el = await QuantumDOM.get('#host-2 >>> shadow-root >>> .nested-shadow #nested-shadow .deep-item');
                TestUtils.assert(el && el.classList.contains('deep-item'), 'Nested shadow structure failed');
            },

            // === Iframe Á©øÈÄèÊµãËØï ===
            async 'Iframe: Basic Penetration'() {
                const el = await QuantumDOM.get('#frm-1 >>> iframe-content >>> #inner-btn');
                TestUtils.assert(el && el.id === 'inner-btn', 'Basic iframe penetration failed');
            },

            async 'Iframe: Complex Path'() {
                const el = await QuantumDOM.get('#frm-2 >>> iframe-content >>> .iframe-class');
                TestUtils.assert(el && el.textContent === 'Iframe Content', 'Complex iframe path failed');
            },

            // === ËæπÁïåÊù°‰ª∂ÂíåÈîôËØØÂ§ÑÁêÜÊµãËØï ===
            async 'Edge: Empty Selector'() {
                try {
                    await QuantumDOM.get('');
                    throw new Error('Should throw error for empty selector');
                } catch (e) {
                    TestUtils.assert(e instanceof QuantumDOM.QuantumError, 'Should throw QuantumError');
                    TestUtils.assert(e.code === 'PARSE', 'Should be parse error');
                }
            },

            async 'Edge: Invalid Selector Type'() {
                try {
                    await QuantumDOM.get(123);
                    throw new Error('Should throw error for invalid selector type');
                } catch (e) {
                    TestUtils.assert(e instanceof Error, 'Should throw some error');
                }
            },

            async 'Edge: Timeout with Null Return'() {
                const result = await QuantumDOM.get('#non-existent', {
                    timeout: 100,
                    returnNullOnTimeout: true
                });
                TestUtils.assert(result === null, 'Should return null on timeout');
            },

            async 'Edge: Timeout with Exception'() {
                const start = Date.now();
                try {
                    await QuantumDOM.get('#definitely-not-existent', { timeout: 200 });
                    throw new Error('Should have timed out');
                } catch (e) {
                    TestUtils.assert(e instanceof QuantumDOM.TimeoutError, 'Wrong error type');
                    TestUtils.assert(Date.now() - start >= 190, 'Timeout too fast');
                }
            },

            // === Each ËßÇÂØüËÄÖÊµãËØï ===
            async 'Each: Static Elements'() {
                let count = 0;
                const stop = QuantumDOM.each('.test-class', (el, isAsync) => {
                    count++;
                    TestUtils.assert(el.id === 'target-2', 'Wrong element matched');
                    TestUtils.assert(isAsync === false, 'Should be sync for initial scan');
                });

                await TestUtils.wait(20);
                stop();
                TestUtils.assert(count === 1, 'Should find exactly 1 element');
            },

            async 'Each: Dynamic Elements'() {
                let count = 0;
                const container = document.querySelector('#dynamic-container');
                TestUtils.assert(container, 'Dynamic container should exist');

                const stop = QuantumDOM.each('.dynamic-item', (el, isAsync) => {
                    count++;
                }, { parent: container });

                await TestUtils.wait(50);

                // Add first element
                const el1 = document.createElement('div');
                el1.className = 'dynamic-item';
                el1.textContent = 'Dynamic 1';
                container.appendChild(el1);

                await TestUtils.wait(50);

                // Add second element
                const el2 = document.createElement('div');
                el2.className = 'dynamic-item';
                el2.textContent = 'Dynamic 2';
                container.appendChild(el2);

                await TestUtils.wait(50);
                stop();

                // Add another after stop (should not be counted)
                const el3 = document.createElement('div');
                el3.className = 'dynamic-item';
                container.appendChild(el3);

                await TestUtils.wait(50);
                TestUtils.assert(count === 2, `Expected 2 dynamic elements, got ${count}`);
                container.innerHTML = '';
            },

            // === ‰∫ã‰ª∂ÂßîÊâòÊµãËØï ===
            async 'On: Simple Delegation'() {
                let clickCount = 0;
                const testBtn = document.querySelector('#btn-test');
                TestUtils.assert(testBtn, 'Test button should exist');

                const stop = await QuantumDOM.on('click', '#btn-test', () => {
                    clickCount++;
                });

                testBtn.click();
                await TestUtils.wait(20);
                testBtn.click();
                await TestUtils.wait(20);

                stop();
                testBtn.click();
                await TestUtils.wait(20);

                TestUtils.assert(clickCount === 2, `Expected 2 clicks, got ${clickCount}`);
            },

            async 'On: Dynamic Elements Delegation'() {
                let clickCount = 0;
                const container = document.querySelector('#event-container');
                TestUtils.assert(container, 'Event container should exist');

                const stop = await QuantumDOM.on('click', '.dynamic-btn', () => {
                    clickCount++;
                }, { parent: container });

                // Add button dynamically
                const btn = document.createElement('button');
                btn.className = 'dynamic-btn';
                btn.textContent = 'Dynamic Button';
                container.appendChild(btn);

                await TestUtils.wait(20);
                btn.click();
                await TestUtils.wait(20);

                TestUtils.assert(clickCount === 1, 'Dynamic button delegation failed');
                stop();
                container.innerHTML = '';
            },

            async 'On: Shadow DOM Delegation'() {
                let clicked = false;
                const stop = await QuantumDOM.on('click', '#host-1 >>> shadow-root >>> #shadow-btn', () => {
                    clicked = true;
                });

                // Find the actual shadow button and click it
                const shadowHost = document.querySelector('#host-1');
                const shadowBtn = shadowHost.shadowRoot.querySelector('#shadow-btn');
                TestUtils.assert(shadowBtn, 'Shadow button should exist');

                shadowBtn.click();
                await TestUtils.wait(20);

                stop();
                shadowBtn.click(); // Should not trigger after stop
                await TestUtils.wait(20);

                TestUtils.assert(clicked, 'Shadow DOM delegation failed');
            },

            async 'On: Iframe Delegation'() {
                let clicked = false;
                const stop = await QuantumDOM.on('click', '#frm-2 >>> iframe-content >>> #iframe-btn-2', () => {
                    clicked = true;
                });

                // Wait for iframe to load and then click
                await TestUtils.wait(100);
                const iframe = document.querySelector('#frm-2');
                TestUtils.assert(iframe && iframe.contentDocument, 'Iframe should be loaded');

                const iframeBtn = iframe.contentDocument.querySelector('#iframe-btn-2');
                TestUtils.assert(iframeBtn, 'Iframe button should exist');

                iframeBtn.click();
                await TestUtils.wait(20);

                stop();
                TestUtils.assert(clicked, 'Iframe delegation failed');
            },

            // === Â∑•ÂÖ∑ÂáΩÊï∞ÊµãËØï ===
            async 'Utils: Create Element'() {
                const container = document.createElement('div');
                document.body.appendChild(container);

                const node = QuantumDOM.create('<div id="created-element">Test Content</div>', { parent: container });
                TestUtils.assert(node && node.id === 'created-element', 'Failed to create element');
                TestUtils.assert(container.contains(node), 'Created element not appended to parent');

                document.body.removeChild(container);
            },

            async 'Utils: Create with ID Map'() {
                const container = document.createElement('div');
                document.body.appendChild(container);

                const map = QuantumDOM.create(`
                    <div id="wrapper">
                        <button id="btn1">Button 1</button>
                        <button id="btn2">Button 2</button>
                    </div>
                `, { mapIds: true, parent: container });

                TestUtils.assert(map && typeof map === 'object', 'Should return map object');
                TestUtils.assert(map.wrapper && map.btn1 && map.btn2, 'Should contain all mapped elements');
                TestUtils.assert(map.btn1.textContent === 'Button 1', 'Mapped button should have correct content');

                document.body.removeChild(container);
            },

            async 'Utils: CSS Injection'() {
                const styleId = 'test-style-' + Date.now();
                const style = QuantumDOM.css(`.test-class-${Date.now()} { color: red; }`, styleId);

                TestUtils.assert(style && style.tagName === 'STYLE', 'Should return style element');
                TestUtils.assert(style.id === styleId, 'Style should have correct ID');
                TestUtils.assert(document.head.contains(style), 'Style should be added to head');

                // Test idempotent injection
                const style2 = QuantumDOM.css(`.another-test { color: blue; }`, styleId);
                TestUtils.assert(style === style2, 'Should return existing style for same ID');
            },

            // === ÁºìÂ≠òÊµãËØï ===
            async 'Cache: Basic Functionality'() {
                // Enable cache
                QuantumDOM.configure({ cache: true });

                const el1 = await QuantumDOM.get('#static-target');
                const el2 = await QuantumDOM.get('#static-target');
                TestUtils.assert(el1 === el2, 'Cache should return same reference');

                // Clear cache and test
                QuantumDOM.clearCache();
                const el3 = await QuantumDOM.get('#static-target');
                TestUtils.assert(el1 === el3, 'Should still return same reference after cache clear');
            },

            async 'Cache: Disabled Cache'() {
                // Disable cache
                QuantumDOM.configure({ cache: false });

                const el1 = await QuantumDOM.get('#target-2');
                const el2 = await QuantumDOM.get('#target-2');

                // Note: We can't guarantee they're different due to browser optimizations,
                // but this test ensures the cache system doesn't break when disabled
                TestUtils.assert(el1 && el2, 'Both elements should exist');
                TestUtils.assert(el1.id === el2.id, 'Both elements should have same ID');

                // Re-enable cache for other tests
                QuantumDOM.configure({ cache: true });
            },

            // === ÊÄßËÉΩÂíåÂπ∂ÂèëÊµãËØï ===
            async 'Performance: Concurrent Gets'() {
                const start = Date.now();
                const promises = [];

                for (let i = 0; i < 10; i++) {
                    promises.push(QuantumDOM.get('#static-target'));
                    promises.push(QuantumDOM.get('#target-2'));
                }

                const results = await Promise.all(promises);
                const duration = Date.now() - start;

                TestUtils.assert(results.length === 20, 'Should return 20 results');
                TestUtils.assert(duration < 1000, 'Concurrent gets should complete quickly');

                // All results should be valid
                results.forEach((result, index) => {
                    TestUtils.assert(result, `Result ${index} should be valid`);
                });
            },

            async 'Performance: Large DOM'() {
                // Create a large DOM structure
                const container = document.createElement('div');
                container.id = 'large-container';

                for (let i = 0; i < 100; i++) {
                    const div = document.createElement('div');
                    div.className = 'large-item';
                    div.textContent = `Item ${i}`;
                    container.appendChild(div);
                }

                document.body.appendChild(container);

                const start = Date.now();
                const element = await QuantumDOM.get('#large-container .large-item:nth-child(50)');
                const duration = Date.now() - start;

                TestUtils.assert(element, 'Should find element in large DOM');
                TestUtils.assert(element.textContent === 'Item 49', 'Should find correct element');
                TestUtils.assert(duration < 500, 'Query should be fast even in large DOM');

                document.body.removeChild(container);
            }
        };

        // --- Test Categories ---
        const testCategories = {
            'Core Tests': ['Core: Library Loading', 'Core: Configuration Management'],
            'Basic Get Operations': ['Get: Element by ID', 'Get: Element by Class', 'Get: Nested Element', 'Get: Array of Selectors'],
            'Shadow DOM Tests': ['Shadow: Basic Penetration', 'Shadow: Button in Shadow', 'Shadow: Nested Structure'],
            'Iframe Tests': ['Iframe: Basic Penetration', 'Iframe: Complex Path'],
            'Edge Cases & Error Handling': ['Edge: Empty Selector', 'Edge: Invalid Selector Type', 'Edge: Timeout with Null Return', 'Edge: Timeout with Exception'],
            'Observer Tests': ['Each: Static Elements', 'Each: Dynamic Elements'],
            'Event Delegation Tests': ['On: Simple Delegation', 'On: Dynamic Elements Delegation', 'On: Shadow DOM Delegation', 'On: Iframe Delegation'],
            'Utility Functions': ['Utils: Create Element', 'Utils: Create with ID Map', 'Utils: CSS Injection'],
            'Caching Tests': ['Cache: Basic Functionality', 'Cache: Disabled Cache'],
            'Performance Tests': ['Performance: Concurrent Gets', 'Performance: Large DOM']
        };

        // --- Enhanced Runner ---
        document.querySelector('#btn-run').onclick = async () => {
            const logEl = document.querySelector('#log');
            logEl.innerHTML = '';

            const startTime = performance.now();
            let totalPassed = 0;
            let totalTests = 0;

            TestUtils.log('info', `üöÄ Starting QuantumDOM v2.1.1 Comprehensive Test Suite`);
            TestUtils.log('info', `üìä Total: ${Object.keys(tests).length} tests in ${Object.keys(testCategories).length} categories`);
            TestUtils.log('info', '');

            for (const [category, testNames] of Object.entries(testCategories)) {
                TestUtils.log('info', `üìÇ ${category}`);

                let categoryPassed = 0;
                let categoryTotal = 0;

                for (const testName of testNames) {
                    if (tests[testName]) {
                        categoryTotal++;
                        const passed = await TestUtils.test(testName, tests[testName]);
                        if (passed) categoryPassed++;
                    }
                }

                totalPassed += categoryPassed;
                totalTests += categoryTotal;

                TestUtils.log('info', `‚úÖ ${categoryPassed}/${categoryTotal} passed in ${category}`);
                TestUtils.log('info', '');
            }

            // Summary
            const duration = performance.now() - startTime;
            const successRate = ((totalPassed / totalTests) * 100).toFixed(1);
            TestUtils.log('info', `üéØ Test Suite Complete`);
            TestUtils.log('info', `üìà Results: ${totalPassed}/${totalTests} passed (${successRate}%)`);

            if (totalPassed === totalTests) {
                TestUtils.log('pass', 'üéâ All tests passed!');
            } else {
                TestUtils.log('fail', `‚ùå ${totalTests - totalPassed} tests failed`);
            }

            // Performance summary
            TestUtils.log('info', `‚è±Ô∏è Test suite completed in ${duration.toFixed(2)}ms`);
        };
    </script>
</body>
</html>