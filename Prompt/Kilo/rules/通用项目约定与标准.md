# 通用项目约定与标准 (Universal Project Conventions and Standards)

This document outlines the core conventions and standards for any software project. As an AI assistant, you MUST adhere to these rules in all your operations, including code generation, refactoring, and planning. This file is your primary source of truth for high-level engineering principles. You must always look for project-specific configuration files (e.g., `package.json`, `.eslintrc`, `pyproject.toml`) to understand the concrete implementation of these principles.

## 1. Core Engineering Philosophy

- **SOLID Principles**: All code must adhere to SOLID principles to ensure it is robust, maintainable, and scalable.
- **DRY (Don't Repeat Yourself)**: Avoid code duplication. Abstract and reuse logic wherever possible by creating reusable functions, classes, or modules.
- **YAGNI (You Ain't Gonna Need It)**: Do not implement functionality that is not explicitly required by the current task. Avoid premature optimization and over-engineering.
- **KISS (Keep It Simple, Stupid)**: Favor simple, clear, and straightforward solutions over complex ones. Code should be as easy to understand as possible.
- **Clean Code**: Code must be readable, well-organized, and consistently formatted according to the project's established style guide (e.g., found in `.prettierrc`, `.editorconfig`).

## 2. Technology and Dependencies

- **Package Manager Consistency**: This project uses a designated package manager. You must infer the correct one (e.g., `npm`, `pnpm`, `yarn`, `pip`, `maven`) by inspecting lock files (`pnpm-lock.yaml`, `package-lock.json`, etc.) or project configuration files. All dependency management commands MUST use the inferred package manager.
- **Dependency Management**: Use specific versions for dependencies to ensure reproducible builds. Avoid using overly broad version ranges. Regularly audit dependencies for security vulnerabilities.

## 3. API Design & Communication (if applicable)

- **Versioning**: All public-facing REST API endpoints must be versioned (e.g., `/api/v1/...`).
- **Consistent Casing**: Use a consistent casing strategy (e.g., `camelCase` or `snake_case`) for JSON request and response bodies, as established by the project's existing code.
- **Standardized Responses**: Use a standardized structure for API responses, including consistent formats for data, pagination, and errors.

## 4. Testing Strategy

- **Testability First**: All new code must be written in a way that is easily testable. This includes separating concerns, using dependency injection, and avoiding side effects in core logic.
- **Comprehensive Coverage**: All new features and significant bug fixes MUST be accompanied by corresponding tests (unit, integration, or E2E).
- **Test File Convention**: Follow the project's established convention for naming and locating test files (e.g., collocated with source files, in a separate `tests/` directory).
- **Mocking**: Use the project's designated mocking strategy and tools to isolate components and services during testing.

## 5. Git and Version Control

- **Commit Messages**: All commit messages **MUST** follow the [Conventional Commits specification](https://www.conventionalcommits.org/). This is a non-negotiable standard for maintaining a clean and understandable version history.
  - Example: `feat(api): add user authentication endpoint`
- **Branching Strategy**: Follow a consistent branching model, such as GitFlow (using `main`, `develop`, `feat/`, `fix/` branches).

## 6. Security

- **Principle of Least Privilege**: Code should only have the permissions necessary to perform its function.
- **Input Validation**: All external input (from users, APIs, files) MUST be validated and sanitized to prevent injection attacks (SQLi, XSS, etc.).
- **Secrets Management**: Never commit secrets (API keys, passwords, certificates) directly into the repository. Use environment variables or a dedicated secrets management tool.
